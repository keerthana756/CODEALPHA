# -*- coding: utf-8 -*-
"""Copy of Chatbot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12wZW3F282uaCnN0FY9uecdTBuhxXRoNF
"""

!pip install nltk spacy
!python -m spacy download en_core_web_sm

#IMPORT LIBRARIES
import nltk
import spacy
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

#Prepare FAQ Data
# FAQ Dataset
faq_data = {
    "What is your product?": "Our product is an AI-powered chatbot designed for businesses.",
    "How much does it cost?": "Pricing varies based on the subscription plan. Contact us for details.",
    "What support do you provide?": "We offer 24/7 customer support via chat and email.",
    "How can I contact sales?": "You can reach our sales team at sales@example.com.",
    "Can I customize the chatbot?": "Yes, the chatbot is fully customizable to meet your needs.",
    "How do I sign up?": "Visit our website and click on 'Sign Up' to get started.",
    "What payment methods do you accept?": "We accept credit cards, PayPal, and bank transfers."
}

#Create a Preprocessing Function
nlp = spacy.load("en_core_web_sm")

def preprocess_text(text):
    doc = nlp(text.lower())
    tokens = [token.lemma_ for token in doc if not token.is_stop and not token.is_punct]
    return " ".join(tokens)

#Preprocess the questions:
processed_questions = [preprocess_text(q) for q in faq_data.keys()]

#Vectorize Text with TF-IDF
vectorizer = TfidfVectorizer()
question_vectors = vectorizer.fit_transform(processed_questions)

def chatbot_response(user_input):
    # Preprocess the user input
    user_input_processed = preprocess_text(user_input)
    # Transform user input to vector
    user_input_vector = vectorizer.transform([user_input_processed])

    # Compute cosine similarity between the user input and all FAQ questions
    similarities = cosine_similarity(user_input_vector, question_vectors)

    # Find the index of the best-matching question
    best_match_idx = np.argmax(similarities[0])  # Corrected: Take the highest similarity value

    # Check if the similarity score meets the threshold
    if similarities[0, best_match_idx] > 0.2:  # Adjust threshold as needed
        best_question = list(faq_data.keys())[best_match_idx]
        return faq_data[best_question]  # Return the answer for the best-matching question
    else:
        return "I'm sorry, I couldn't find an answer to that. Could you rephrase your question?"

# Main chatbot loop
print("Welcome to the FAQ chatbot! Type 'exit' to quit.")

while True:
    user_query = input("You: ")
    if user_query.lower() == "exit":
        print("Chatbot: Goodbye!")
        break
    response = chatbot_response(user_query)
    print(f"Chatbot: {response}")